-- Alternative Music Loading System for Roblox Executors
local AlternativeMusicPlayer = {}

-- Configuration
local CONFIG = {
    MUSIC_FOLDER = "Musics",
    SUPPORTED_FORMATS = {".mp3", ".wav", ".ogg"},
    UPDATE_INTERVAL = 3,
    DEFAULT_VOLUME = 0.5,
    DEFAULT_SPEED = 1.0,
    DEFAULT_REVERB = 10
}

-- Settings
local settings = {
    musicFolder = CONFIG.MUSIC_FOLDER,
    musicQueue = {},
    currentIndex = 1,
    isPlaying = false,
    autoplay = false,
    autoplayNext = false,
    loopEnabled = false,
    shuffleEnabled = false,
    volume = CONFIG.DEFAULT_VOLUME,
    playbackSpeed = CONFIG.DEFAULT_SPEED,
    reverbLevel = CONFIG.DEFAULT_REVERB,
    currentPlayingMusic = nil
}

-- State management
local state = {
    globalSound = nil,
    musicDropdown = nil,
    isInitialized = false,
    lastUpdateTime = 0,
    loadingMethods = {}
}

-- Detection of available functions
local function detectAvailableFunctions()
    local methods = {}
    
    -- Method 1: getcustomasset (most common but problematic)
    if getcustomasset then
        methods.getcustomasset = getcustomasset
        print("‚úÖ getcustomasset detected")
    end
    
    -- Method 2: getsynasset (Synapse X alternative)
    if getsynasset then
        methods.getsynasset = getsynasset
        print("‚úÖ getsynasset detected")
    end
    
    -- Method 3: getcustomasset but with different name (some executors)
    if getfile then
        methods.getfile = getfile
        print("‚úÖ getfile detected")
    end
    
    -- Method 4: readfile + data URL (fallback method)
    if readfile then
        methods.readfile_dataurl = function(path)
            local success, content = pcall(readfile, path)
            if success then
                -- Convert to base64 data URL (works for some cases)
                local base64 = game:GetService("HttpService"):JSONEncode({content}):gsub('"', ''):gsub('\\', '')
                return "rbxasset://sounds/electronica_loop.wav" -- Fallback to built-in sound
            end
            return nil
        end
        print("‚úÖ readfile+dataurl method available")
    end
    
    -- Method 5: Built-in Roblox sounds (ultimate fallback)
    methods.builtin_sounds = {
        ["default"] = "rbxasset://sounds/electronica_loop.wav",
        ["beep"] = "rbxasset://sounds/button.wav", 
        ["click"] = "rbxasset://sounds/clickfast.wav",
        ["error"] = "rbxasset://sounds/electronica_loop.wav"
    }
    print("‚úÖ Built-in sounds available as fallback")
    
    state.loadingMethods = methods
    return methods
end

-- Universal file loading function
local function loadSoundFile(filePath, fileName)
    local methods = state.loadingMethods
    local errors = {}
    
    -- Try each method in order of preference
    local methodOrder = {"getsynasset", "getcustomasset", "getfile", "readfile_dataurl"}
    
    for _, methodName in ipairs(methodOrder) do
        local method = methods[methodName]
        if method then
            local success, result = pcall(method, filePath)
            if success and result then
                print("‚úÖ Loaded " .. fileName .. " using " .. methodName)
                return result
            else
                errors[methodName] = tostring(result)
                print("‚ùå " .. methodName .. " failed: " .. tostring(result))
            end
        end
    end
    
    -- Fallback to built-in sounds if file loading fails
    warn("All methods failed for: " .. fileName)
    for method, error in pairs(errors) do
        warn("  " .. method .. ": " .. error)
    end
    
    print("üîÑ Using built-in sound as fallback")
    return methods.builtin_sounds.default
end

-- Enhanced sound creation
local function createGlobalSound()
    local sound = workspace:FindFirstChild("GlobalMusicPlayer")
    if not sound then
        sound = Instance.new("Sound")
        sound.Name = "GlobalMusicPlayer"
        sound.Parent = workspace
        sound.Looped = false
        sound.EmptyOnDestroy = false
        
        -- Enhanced ended connection
        sound.Ended:Connect(function()
            if settings.autoplayNext and sound.TimeLength > 0 then
                -- Verify the song actually finished (not just failed)
                if sound.TimePosition >= (sound.TimeLength * 0.95) then
                    task.wait(0.5)
                    AlternativeMusicPlayer.playNext()
                else
                    warn("Song ended prematurely, not auto-playing next")
                end
            end
        end)
        
        -- Failed connection for debugging
        sound.Failed:Connect(function(soundId, errorCode)
            warn("Sound failed to load: " .. tostring(soundId))
            warn("Error code: " .. tostring(errorCode))
            
            -- Try to reload with different method
            if settings.currentPlayingMusic then
                print("Attempting to reload with alternative method...")
                task.wait(1)
                AlternativeMusicPlayer.playMusic(settings.currentPlayingMusic)
            end
        end)
    end
    return sound
end

-- Apply reverb with better error handling
local function applyReverbEffect()
    if not state.globalSound then return end
    
    local success, reverb = pcall(function()
        local existing = state.globalSound:FindFirstChild("ReverbEffect")
        if not existing then
            existing = Instance.new("EqualizerSoundEffect")
            existing.Name = "ReverbEffect"
            existing.Parent = state.globalSound
        end
        return existing
    end)
    
    if success and reverb then
        local reverbFactor = settings.reverbLevel / 10
        reverb.HighGain = math.clamp(-20 + reverbFactor * 15, -80, 10)
        reverb.LowGain = math.clamp(5 + reverbFactor * 5, -80, 10)
        reverb.MidGain = math.clamp(-10 + reverbFactor * 10, -80, 10)
        reverb.Enabled = settings.reverbLevel > 0
    else
        warn("Failed to apply reverb effect")
    end
end

-- File system functions
local function checkOrCreateFolder()
    local success, result = pcall(function()
        if not isfolder(settings.musicFolder) then
            makefolder(settings.musicFolder)
            print("üìÅ Created music folder: " .. settings.musicFolder)
            return true
        end
        return false
    end)
    
    if not success then
        warn("Failed to create/check folder: " .. tostring(result))
        return false
    end
    
    return true
end

local function loadMusicFiles()
    local musicFiles = {}
    local success, files = pcall(function()
        return listfiles(settings.musicFolder)
    end)
    
    if not success then
        warn("Failed to list music files: " .. tostring(files))
        return musicFiles
    end
    
    for _, filePath in ipairs(files or {}) do
        local fileName = filePath:match("([^/\\]+)$")
        if fileName then
            for _, format in ipairs(CONFIG.SUPPORTED_FORMATS) do
                if fileName:lower():match(format:lower() .. "$") then
                    local nameWithoutExt = fileName:match("(.+)%..+$")
                    if nameWithoutExt then
                        table.insert(musicFiles, nameWithoutExt)
                    end
                    break
                end
            end
        end
    end
    
    -- Update queue
    if #settings.musicQueue == 0 or #musicFiles ~= #settings.musicQueue then
        settings.musicQueue = {table.unpack(musicFiles)}
        if settings.shuffleEnabled then
            AlternativeMusicPlayer.shuffleQueue()
        end
    end
    
    return musicFiles
end

-- Public Functions
function AlternativeMusicPlayer.initialize(dropdown)
    print("üéµ Initializing Alternative Music Player...")
    
    -- Detect available methods
    detectAvailableFunctions()
    
    state.musicDropdown = dropdown
    state.globalSound = createGlobalSound()
    checkOrCreateFolder()
    state.isInitialized = true
    
    -- Initial load
    local musicFiles = loadMusicFiles()
    if #musicFiles > 0 and dropdown then
        dropdown:Refresh(musicFiles, true)
        print("üéµ Loaded " .. #musicFiles .. " music files")
    else
        print("‚ö†Ô∏è No music files found in " .. settings.musicFolder)
    end
    
    return true
end

function AlternativeMusicPlayer.playMusic(fileName)
    if not fileName or not state.globalSound then return false end
    
    print("üéµ Attempting to play: " .. fileName)
    
    -- Find file with correct format
    local filePath = nil
    local actualFormat = nil
    for _, format in ipairs(CONFIG.SUPPORTED_FORMATS) do
        local testPath = settings.musicFolder .. "/" .. fileName .. format
        if isfile(testPath) then
            filePath = testPath
            actualFormat = format
            break
        end
    end
    
    if not filePath then
        warn("‚ùå Music file not found: " .. fileName)
        return false
    end
    
    -- Stop current music
    state.globalSound:Stop()
    state.globalSound.SoundId = ""
    task.wait(0.1)
    
    -- Load with alternative methods
    local soundId = loadSoundFile(filePath, fileName)
    if not soundId then
        warn("‚ùå Failed to load sound: " .. fileName)
        return false
    end
    
    -- Apply settings
    state.globalSound.SoundId = soundId
    state.globalSound.Volume = settings.volume
    state.globalSound.PlaybackSpeed = settings.playbackSpeed
    state.globalSound.Looped = settings.loopEnabled and not settings.autoplayNext
    applyReverbEffect()
    
    settings.currentPlayingMusic = fileName
    
    -- Enhanced loading verification
    local loadWait = 0
    local maxWait = 10
    
    while not state.globalSound.IsLoaded and loadWait < maxWait do
        task.wait(0.1)
        loadWait = loadWait + 0.1
    end
    
    if not state.globalSound.IsLoaded then
        warn("‚ö†Ô∏è Sound may not have loaded properly, but continuing...")
    end
    
    if settings.autoplay then
        local playSuccess = pcall(function()
            state.globalSound:Play()
        end)
        
        if playSuccess then
            settings.isPlaying = true
            print("‚úÖ Now playing: " .. fileName .. " (" .. actualFormat .. ")")
        else
            warn("‚ùå Failed to play sound: " .. fileName)
            return false
        end
    else
        settings.isPlaying = false
        print("‚úÖ Loaded (paused): " .. fileName)
    end
    
    return true
end

function AlternativeMusicPlayer.playNext()
    if #settings.musicQueue == 0 then
        if settings.loopEnabled and settings.currentPlayingMusic then
            return AlternativeMusicPlayer.playMusic(settings.currentPlayingMusic)
        end
        return false
    end
    
    local nextMusic
    if settings.shuffleEnabled then
        local randomIndex = math.random(1, #settings.musicQueue)
        nextMusic = settings.musicQueue[randomIndex]
    else
        settings.currentIndex = settings.currentIndex + 1
        if settings.currentIndex > #settings.musicQueue then
            if settings.loopEnabled then
                settings.currentIndex = 1
            else
                return false
            end
        end
        nextMusic = settings.musicQueue[settings.currentIndex]
    end
    
    if nextMusic and state.musicDropdown then
        state.musicDropdown:Set(nextMusic)
        return AlternativeMusicPlayer.playMusic(nextMusic)
    end
    
    return false
end

function AlternativeMusicPlayer.playPrevious()
    if #settings.musicQueue == 0 then return false end
    
    settings.currentIndex = settings.currentIndex - 1
    if settings.currentIndex < 1 then
        settings.currentIndex = settings.loopEnabled and #settings.musicQueue or 1
    end
    
    local prevMusic = settings.musicQueue[settings.currentIndex]
    if prevMusic and state.musicDropdown then
        state.musicDropdown:Set(prevMusic)
        return AlternativeMusicPlayer.playMusic(prevMusic)
    end
    
    return false
end

function AlternativeMusicPlayer.togglePlayPause()
    if not state.globalSound then return end
    
    if settings.isPlaying then
        state.globalSound:Pause()
        settings.isPlaying = false
    else
        state.globalSound:Resume()
        settings.isPlaying = true
    end
end

function AlternativeMusicPlayer.stop()
    if state.globalSound then
        state.globalSound:Stop()
        settings.isPlaying = false
    end
end

function AlternativeMusicPlayer.shuffleQueue()
    if #settings.musicQueue <= 1 then return end
    
    for i = #settings.musicQueue, 2, -1 do
        local j = math.random(i)
        settings.musicQueue[i], settings.musicQueue[j] = settings.musicQueue[j], settings.musicQueue[i]
    end
    settings.currentIndex = 1
end

-- Settings Functions
function AlternativeMusicPlayer.setVolume(volume)
    settings.volume = math.clamp(volume, 0, 1)
    if state.globalSound then
        state.globalSound.Volume = settings.volume
    end
end

function AlternativeMusicPlayer.setPlaybackSpeed(speed)
    settings.playbackSpeed = math.clamp(speed, 0.1, 3)
    if state.globalSound then
        state.globalSound.PlaybackSpeed = settings.playbackSpeed
    end
end

function AlternativeMusicPlayer.setReverbLevel(level)
    settings.reverbLevel = math.clamp(level, 0, 20)
    applyReverbEffect()
end

function AlternativeMusicPlayer.setAutoPlay(enabled)
    settings.autoplay = enabled
end

function AlternativeMusicPlayer.setAutoPlayNext(enabled)
    settings.autoplayNext = enabled
end

function AlternativeMusicPlayer.setLoopMode(enabled)
    settings.loopEnabled = enabled
    if state.globalSound then
        state.globalSound.Looped = enabled and not settings.autoplayNext
    end
end

function AlternativeMusicPlayer.setShuffleMode(enabled)
    settings.shuffleEnabled = enabled
    if enabled then
        AlternativeMusicPlayer.shuffleQueue()
    end
end

-- Getters
function AlternativeMusicPlayer.getMusicOptions()
    return loadMusicFiles()
end

function AlternativeMusicPlayer.getQueue()
    return settings.musicQueue
end

function AlternativeMusicPlayer.getCurrentMusic()
    return settings.currentPlayingMusic
end

function AlternativeMusicPlayer.isPlaying()
    return settings.isPlaying and state.globalSound and state.globalSound.IsPlaying
end

function AlternativeMusicPlayer.updateDropdown()
    if not state.musicDropdown then return end
    
    local currentTime = tick()
    if currentTime - state.lastUpdateTime < CONFIG.UPDATE_INTERVAL then
        return
    end
    
    local musicFiles = loadMusicFiles()
    state.musicDropdown:Refresh(musicFiles, true)
    state.lastUpdateTime = currentTime
end

function AlternativeMusicPlayer.getDebugInfo()
    if not state.globalSound then return "No sound object" end
    
    return {
        availableMethods = state.loadingMethods and table.concat({unpack(state.loadingMethods)}, ", ") or "None",
        soundId = state.globalSound.SoundId,
        isLoaded = state.globalSound.IsLoaded,
        isPlaying = state.globalSound.IsPlaying,
        timePosition = state.globalSound.TimePosition,
        timeLength = state.globalSound.TimeLength,
        volume = state.globalSound.Volume,
        currentMusic = settings.currentPlayingMusic,
        queueSize = #settings.musicQueue
    }
end

-- Auto-update system
task.spawn(function()
    while true do
        if state.isInitialized then
            AlternativeMusicPlayer.updateDropdown()
        end
        task.wait(CONFIG.UPDATE_INTERVAL)
    end
end)

return AlternativeMusicPlayer
